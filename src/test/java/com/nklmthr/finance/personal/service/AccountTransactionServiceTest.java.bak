package com.nklmthr.finance.personal.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.lenient;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.ResponseEntity;
import org.springframework.test.util.ReflectionTestUtils;

import com.nklmthr.finance.personal.dto.AccountDTO;
import com.nklmthr.finance.personal.dto.AccountTransactionDTO;
import com.nklmthr.finance.personal.dto.CategoryDTO;
import com.nklmthr.finance.personal.dto.TransferRequest;
import com.nklmthr.finance.personal.enums.TransactionType;
import com.nklmthr.finance.personal.mapper.AccountMapper;
import com.nklmthr.finance.personal.mapper.AccountTransactionMapper;
import com.nklmthr.finance.personal.mapper.CategoryMapper;
import com.nklmthr.finance.personal.model.Account;
import com.nklmthr.finance.personal.model.AccountTransaction;
import com.nklmthr.finance.personal.model.AppUser;
import com.nklmthr.finance.personal.model.Category;
import com.nklmthr.finance.personal.repository.AccountRepository;
import com.nklmthr.finance.personal.repository.AccountTransactionRepository;

@ExtendWith(MockitoExtension.class)
class AccountTransactionServiceTest {

    @Mock
    private AppUserService appUserService;

    @Mock
    private AccountRepository accountRepository;

    @Mock
    private AccountTransactionRepository accountTransactionRepository;

    @Mock
    private CategoryService categoryService;

    @Mock
    private AccountTransactionMapper accountTransactionMapper;

    @Mock
    private AccountMapper accountMapper;

    @Mock
    private CategoryMapper categoryMapper;

    @InjectMocks
    private AccountTransactionService service;

    private AppUser currentUser;

    @BeforeEach
    void setUp() {
        currentUser = AppUser.builder()
            .id("user-1")
            .username("jane.doe")
            .password("pass")
            .role("USER")
            .email("jane@example.com")
            .build();
        lenient().when(appUserService.getCurrentUser()).thenReturn(currentUser);

        // Inject mocks into @Autowired fields
        ReflectionTestUtils.setField(service, "appUserService", appUserService);
        ReflectionTestUtils.setField(service, "accountRepository", accountRepository);
        ReflectionTestUtils.setField(service, "accountTransactionRepository", accountTransactionRepository);
        ReflectionTestUtils.setField(service, "categoryService", categoryService);
        ReflectionTestUtils.setField(service, "accountTransactionMapper", accountTransactionMapper);
        ReflectionTestUtils.setField(service, "accountMapper", accountMapper);
        ReflectionTestUtils.setField(service, "categoryMapper", categoryMapper);
    }

    private Account createAccount(String id, BigDecimal balance) {
        Account a = new Account();
        a.setId(id);
        a.setName("A-" + id);
        a.setBalance(balance);
        a.setAppUser(currentUser);
        return a;
    }

    @Test
    void createTransfer_updatesBalancesAndCreatesCredit() throws Exception {
        Account from = createAccount("a1", new BigDecimal("1000"));
        Account to = createAccount("a2", new BigDecimal("500"));
        AccountTransaction debit = AccountTransaction.builder()
            .id("tx1").amount(new BigDecimal("100")).type(TransactionType.DEBIT)
            .account(from).appUser(currentUser).description("Transfer out").build();
        Category transferCat = new Category();
        transferCat.setId("ct");
        transferCat.setName("TRANSFERS");
        transferCat.setAppUser(currentUser);

        when(accountTransactionRepository.findByAppUserAndId(currentUser, "tx1")).thenReturn(Optional.of(debit));
        when(categoryService.getTransferCategory()).thenReturn(transferCat);
        when(accountRepository.findByAppUserAndId(currentUser, "a2")).thenReturn(Optional.of(to));

        service.createTransfer(TransferRequest.builder()
            .sourceTransactionId("tx1").destinationAccountId("a2").explanation("x").build());

        assertThat(from.getBalance()).isEqualByComparingTo("900");
        assertThat(to.getBalance()).isEqualByComparingTo("600");
        verify(accountTransactionRepository, times(1)).save(debit);
        verify(accountRepository, times(1)).save(from);
        verify(accountRepository, times(1)).save(to);

        ArgumentCaptor<AccountTransaction> creditCaptor = ArgumentCaptor.forClass(AccountTransaction.class);
        verify(accountTransactionRepository, times(2)).save(creditCaptor.capture());
        AccountTransaction credit = creditCaptor.getAllValues().get(1);
        assertThat(credit.getAccount()).isEqualTo(to);
        assertThat(credit.getType()).isEqualTo(TransactionType.CREDIT);
        assertThat(credit.getAmount()).isEqualByComparingTo("100");
        assertThat(credit.getCategory()).isEqualTo(transferCat);
    }

    @Test
    void createTransfer_preventsTransferOfSplitTransaction() {
        Account from = createAccount("a1", new BigDecimal("1000"));
        AccountTransaction parent = AccountTransaction.builder()
            .id("p1").amount(BigDecimal.ZERO).type(TransactionType.DEBIT)
            .account(from).appUser(currentUser).description("Split transaction").build();
        AccountTransaction child = AccountTransaction.builder()
            .id("c1").amount(new BigDecimal("100")).type(TransactionType.DEBIT)
            .account(from).appUser(currentUser).parent("p1").build();

        when(accountTransactionRepository.findByAppUserAndId(currentUser, "p1")).thenReturn(Optional.of(parent));
        when(accountTransactionRepository.findByAppUserAndParent(currentUser, "p1")).thenReturn(List.of(child));

        TransferRequest request = TransferRequest.builder()
            .sourceTransactionId("p1")
            .destinationAccountId("a2")
            .explanation("Transfer attempt")
            .build();

        assertThatThrownBy(() -> service.createTransfer(request))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Cannot transfer a split transaction");

        // Verify no changes were made
        verify(accountTransactionRepository, never()).save(any(AccountTransaction.class));
        verify(accountRepository, never()).save(any(Account.class));
    }

    @Test
    void splitTransaction_successful() {
        Account account = createAccount("a1", new BigDecimal("1000"));
        AccountTransaction parent = AccountTransaction.builder()
            .id("p1").amount(new BigDecimal("300")).account(account).appUser(currentUser).currency("INR").build();
        when(accountTransactionRepository.findById("p1")).thenReturn(Optional.of(parent));
        when(accountTransactionRepository.findByAppUserAndParent(currentUser, "p1")).thenReturn(List.of());
        Category splitCat = new Category();
        splitCat.setId("split");
        splitCat.setName("SPLIT");
        splitCat.setAppUser(currentUser);
        when(categoryService.getSplitTrnsactionCategory()).thenReturn(splitCat);
        Category foodCat = new Category();
        foodCat.setId("cat");
        foodCat.setName("Food");
        foodCat.setAppUser(currentUser);
        when(categoryService.getCategoryById("cat")).thenReturn(foodCat);

        CategoryDTO catDTO = new CategoryDTO();
        catDTO.setId("cat");
        AccountDTO accDTO = new AccountDTO("a1", "Test Account", BigDecimal.ZERO, null, null, null, null, null);

        AccountTransactionDTO st1 = new AccountTransactionDTO(
            null,
            LocalDateTime.now(),
            new BigDecimal("100"),
            "s1",
            null,
            null,
            null,
            TransactionType.DEBIT,
            accDTO,
            catDTO,
            "p1",
            List.of(),
            null,
            null,
            null,
            null,
            "INR",
            null
        );

        AccountTransactionDTO st2 = new AccountTransactionDTO(
            null,
            LocalDateTime.now(),
            new BigDecimal("200"),
            "s2",
            null,
            null,
            null,
            TransactionType.DEBIT,
            accDTO,
            catDTO,
            "p1",
            List.of(),
            null,
            null,
            null,
            null,
            "INR",
            null
        );

        ResponseEntity<String> resp = service.splitTransaction(List.of(st1, st2));
        assertThat(resp.getStatusCode().is2xxSuccessful()).isTrue();
        verify(accountTransactionRepository, times(3)).save(any(AccountTransaction.class)); // two children + parent
        verify(accountTransactionRepository, times(1)).save(parent); // parent saved once
    }

    @Test
    void splitTransaction_badRequestWhenEmpty() {
        ResponseEntity<String> resp = service.splitTransaction(List.of());
        assertThat(resp.getStatusCode().is4xxClientError()).isTrue();
    }

    @Test
    void splitTransaction_badRequestWhenParentMissing() {
        when(accountTransactionRepository.findById("p1")).thenReturn(Optional.empty());
        AccountTransactionDTO st = new AccountTransactionDTO(
            null,
            LocalDateTime.now(),
            new BigDecimal("100"),
            "test",
            null,
            null,
            null,
            TransactionType.DEBIT,
            null,
            new CategoryDTO(),
            "p1",
            List.of(),
            null,
            null,
            null,
            null,
            "INR",
            null
        );
        ResponseEntity<String> resp = service.splitTransaction(List.of(st));
        assertThat(resp.getStatusCode().is4xxClientError()).isTrue();
    }

    @Test
    void updateTransaction_sameAccount_adjustsBalance() {
        Account acc = createAccount("a1", new BigDecimal("1000"));
        AccountTransaction existing = AccountTransaction.builder()
            .id("tx1").amount(new BigDecimal("50")).type(TransactionType.DEBIT)
            .account(acc).appUser(currentUser).build();

        when(accountTransactionRepository.findById("tx1")).thenReturn(Optional.of(existing));
        when(accountRepository.findByAppUserAndId(currentUser, "a1")).thenReturn(Optional.of(acc));
        Category foodCat2 = new Category();
        foodCat2.setId("cat");
        foodCat2.setName("Food");
        foodCat2.setAppUser(currentUser);
        when(categoryService.getCategoryById("cat")).thenReturn(foodCat2);

        AccountTransaction mapped = new AccountTransaction();
        when(accountTransactionMapper.toEntity(any(AccountTransactionDTO.class))).thenReturn(mapped);
        when(accountTransactionRepository.save(mapped)).thenReturn(mapped);
        when(accountTransactionMapper.toDTO(mapped)).thenReturn(new AccountTransactionDTO("tx1", LocalDateTime.now(), new BigDecimal("20"), "d", null, null, null, TransactionType.CREDIT, new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO(), null, List.of(), null, null, null, null, null, null));

        AccountTransactionDTO update = new AccountTransactionDTO("tx1", LocalDateTime.now(), new BigDecimal("20"), "d", null, null, null, TransactionType.CREDIT, new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO("cat", "Food", null, false, List.of()), null, List.of(), null, null, null, null, null, null);

        Optional<AccountTransactionDTO> result = service.updateTransaction("tx1", update);

        assertThat(result).isPresent();
        // oldType=DEBIT refunds 50, then CREDIT adds 20 => 1070
        assertThat(acc.getBalance()).isEqualByComparingTo("1070");
        verify(accountTransactionRepository, times(1)).save(mapped);
    }

    @Test
    void updateTransaction_differentAccount_adjustsBoth() {
        Account oldAcc = createAccount("a1", new BigDecimal("1000"));
        Account newAcc = createAccount("a2", new BigDecimal("500"));
        AccountTransaction existing = AccountTransaction.builder()
            .id("tx1").amount(new BigDecimal("30")).type(TransactionType.CREDIT)
            .account(oldAcc).appUser(currentUser).build();

        when(accountTransactionRepository.findById("tx1")).thenReturn(Optional.of(existing));
        when(accountRepository.findByAppUserAndId(currentUser, "a2")).thenReturn(Optional.of(newAcc));
        Category foodCat3 = new Category();
        foodCat3.setId("cat");
        foodCat3.setName("Food");
        foodCat3.setAppUser(currentUser);
        when(categoryService.getCategoryById("cat")).thenReturn(foodCat3);

        AccountTransaction mapped = new AccountTransaction();
        when(accountTransactionMapper.toEntity(any(AccountTransactionDTO.class))).thenReturn(mapped);
        when(accountTransactionRepository.save(mapped)).thenReturn(mapped);
        when(accountTransactionMapper.toDTO(mapped)).thenReturn(new AccountTransactionDTO("tx1", LocalDateTime.now(), new BigDecimal("40"), "d", null, null, null, TransactionType.DEBIT, new AccountDTO("a2","A-2", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO(), null, List.of(), null, null, null, null, null, null));

        AccountTransactionDTO update = new AccountTransactionDTO("tx1", LocalDateTime.now(), new BigDecimal("40"), "d", null, null, null, TransactionType.DEBIT, new AccountDTO("a2","A-2", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO("cat", "Food", null, false, List.of()), null, List.of(), null, null, null, null, null, null);

        Optional<AccountTransactionDTO> result = service.updateTransaction("tx1", update);

        assertThat(result).isPresent();
        // oldType=CREDIT: oldAcc -= 30 => 970; newType=DEBIT on newAcc: 500 - 40 => 460
        assertThat(oldAcc.getBalance()).isEqualByComparingTo("970");
        assertThat(newAcc.getBalance()).isEqualByComparingTo("460");
        verify(accountRepository).save(oldAcc);
        verify(accountRepository).save(newAcc);
    }

    @Test
    void updateTransaction_withChildren_preventsAmountChange() {
        Account acc = createAccount("a1", new BigDecimal("1000"));
        AccountTransaction parent = AccountTransaction.builder()
            .id("p1").amount(BigDecimal.ZERO).type(TransactionType.DEBIT)
            .account(acc).appUser(currentUser).build();
        AccountTransaction child = AccountTransaction.builder()
            .id("c1").amount(new BigDecimal("100")).type(TransactionType.DEBIT)
            .account(acc).appUser(currentUser).parent("p1").build();

        when(accountTransactionRepository.findById("p1")).thenReturn(Optional.of(parent));
        when(accountTransactionRepository.findByAppUserAndParent(currentUser, "p1")).thenReturn(List.of(child));
        when(accountRepository.findByAppUserAndId(currentUser, "a1")).thenReturn(Optional.of(acc));

        AccountTransactionDTO update = new AccountTransactionDTO(
            "p1", 
            LocalDateTime.now(), 
            new BigDecimal("50"), // trying to change amount
            "Updated description", 
            null, 
            null, 
            null, 
            TransactionType.DEBIT, 
            new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), 
            new CategoryDTO("cat", "Food", null, false, List.of()), 
            null, 
            List.of(), 
            null, 
            null, 
            null, 
            null, 
            null, 
            null
        );

        assertThatThrownBy(() -> service.updateTransaction("p1", update))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Cannot change amount of a split transaction");
    }

    @Test
    void updateTransaction_withChildren_allowsNonAmountChanges() {
        Account acc = createAccount("a1", new BigDecimal("1000"));
        AccountTransaction parent = AccountTransaction.builder()
            .id("p1").amount(BigDecimal.ZERO).type(TransactionType.DEBIT)
            .description("Original description")
            .account(acc).appUser(currentUser).build();
        AccountTransaction child = AccountTransaction.builder()
            .id("c1").amount(new BigDecimal("100")).type(TransactionType.DEBIT)
            .account(acc).appUser(currentUser).parent("p1").build();

        when(accountTransactionRepository.findById("p1")).thenReturn(Optional.of(parent));
        when(accountTransactionRepository.findByAppUserAndParent(currentUser, "p1")).thenReturn(List.of(child));
        when(accountRepository.findByAppUserAndId(currentUser, "a1")).thenReturn(Optional.of(acc));
        
        Category newCat = new Category();
        newCat.setId("newcat");
        newCat.setName("NewCategory");
        newCat.setAppUser(currentUser);
        when(categoryService.getCategoryById("newcat")).thenReturn(newCat);

        AccountTransaction mapped = new AccountTransaction();
        when(accountTransactionMapper.toEntity(any(AccountTransactionDTO.class))).thenReturn(mapped);
        when(accountTransactionRepository.save(mapped)).thenReturn(mapped);
        when(accountTransactionMapper.toDTO(mapped)).thenReturn(
            new AccountTransactionDTO("p1", LocalDateTime.now(), BigDecimal.ZERO, "Updated description", 
                null, null, null, TransactionType.DEBIT, 
                new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), 
                new CategoryDTO("newcat", "NewCategory", null, false, List.of()), 
                null, List.of(), null, null, null, null, null, null)
        );

        AccountTransactionDTO update = new AccountTransactionDTO(
            "p1", 
            LocalDateTime.now(), 
            BigDecimal.ZERO, // same amount - should be allowed
            "Updated description", 
            null, 
            null, 
            null, 
            TransactionType.DEBIT, 
            new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), 
            new CategoryDTO("newcat", "NewCategory", null, false, List.of()), 
            null, 
            List.of(), 
            null, 
            null, 
            null, 
            null, 
            null, 
            null
        );

        Optional<AccountTransactionDTO> result = service.updateTransaction("p1", update);

        assertThat(result).isPresent();
        assertThat(result.get().description()).isEqualTo("Updated description");
        verify(accountTransactionRepository, times(1)).save(mapped);
    }

    @Test
    void save_fromDto_setsDefaultsAndPersists() {
        Account acc = createAccount("a1", new BigDecimal("1000"));
        when(accountRepository.findByAppUserAndId(currentUser, "a1")).thenReturn(Optional.of(acc));

        AccountTransaction mapped = new AccountTransaction();
        mapped.setAccount(acc);
        mapped.setGptAccount(null);
        when(accountTransactionMapper.toEntity(any(AccountTransactionDTO.class))).thenAnswer(inv -> {
            AccountTransactionDTO dto = inv.getArgument(0);
            mapped.setType(dto.type());
            mapped.setAmount(dto.amount());
            mapped.setAccount(acc);
            mapped.setGptAccount(null);
            return mapped;
        });
        when(accountTransactionRepository.save(mapped)).thenReturn(mapped);
        when(accountTransactionMapper.toDTO(mapped)).thenReturn(new AccountTransactionDTO("txN", LocalDateTime.now(), new BigDecimal("10"), "d", null, null, null, TransactionType.DEBIT, new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO(), null, List.of(), null, null, null, null, null, null));

        AccountTransactionDTO input = new AccountTransactionDTO(null, LocalDateTime.now(), new BigDecimal("10"), "d", null, null, null, TransactionType.DEBIT, new AccountDTO("a1","A-1", BigDecimal.ZERO, null, null, null, null, null), new CategoryDTO(), null, List.of(), null, null, null, null, null, null);

        AccountTransactionDTO result = service.save(input);
        assertThat(result.id()).isEqualTo("txN");
        // gptAccount should be set same as account when null
        assertThat(mapped.getGptAccount()).isEqualTo(acc);
    }

    @Test
    void getById_mapsToDto() {
        AccountTransaction entity = AccountTransaction.builder().id("t1").appUser(currentUser).build();
        AccountTransactionDTO dto = new AccountTransactionDTO("t1", LocalDateTime.now(), BigDecimal.ZERO, null, null, null, null, TransactionType.DEBIT, null, null, null, List.of(), null, null, null, null, null, null);
        when(accountTransactionRepository.findByAppUserAndId(currentUser, "t1")).thenReturn(Optional.of(entity));
        when(accountTransactionMapper.toDTO(entity)).thenReturn(dto);

        Optional<AccountTransactionDTO> result = service.getById("t1");
        assertThat(result).contains(dto);
    }

    @Test
    void getChildren_mapsToDtos() {
        AccountTransaction e1 = AccountTransaction.builder().id("c1").appUser(currentUser).build();
        AccountTransaction e2 = AccountTransaction.builder().id("c2").appUser(currentUser).build();
        when(accountTransactionRepository.findByAppUserAndParent(currentUser, "p1")).thenReturn(List.of(e1, e2));
        AccountTransactionDTO d1 = new AccountTransactionDTO("c1", LocalDateTime.now(), BigDecimal.ZERO, null, null, null, null, TransactionType.DEBIT, null, null, null, List.of(), null, null, null, null, null, null);
        AccountTransactionDTO d2 = new AccountTransactionDTO("c2", LocalDateTime.now(), BigDecimal.ZERO, null, null, null, null, TransactionType.DEBIT, null, null, null, List.of(), null, null, null, null, null, null);
        when(accountTransactionMapper.toDTOList(List.of(e1, e2))).thenReturn(List.of(d1, d2));

        List<AccountTransactionDTO> result = service.getChildren("p1");
        assertThat(result).containsExactly(d1, d2);
    }

    @Test
    void delete_throwsWhenHasChildren() {
        AccountTransaction existing = AccountTransaction.builder().id("t1").appUser(currentUser).build();
        when(accountTransactionRepository.findByAppUserAndId(currentUser, "t1")).thenReturn(Optional.of(existing));
        when(accountTransactionRepository.findByParentAndAppUser("t1", currentUser)).thenReturn(List.of(existing));

        assertThatThrownBy(() -> service.delete("t1")).isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("children");
    }

    @Test
    void delete_updatesParentAndDeletes() {
        AccountTransaction parent = AccountTransaction.builder().id("p1").amount(new BigDecimal("200")).appUser(currentUser).description("Parent").build();
        AccountTransaction child = AccountTransaction.builder().id("t1").amount(new BigDecimal("50")).parent("p1").appUser(currentUser).description("Child").build();
        when(accountTransactionRepository.findByAppUserAndId(currentUser, "t1")).thenReturn(Optional.of(child));
        when(accountTransactionRepository.findByAppUserAndId(currentUser, "p1")).thenReturn(Optional.of(parent));
        when(accountTransactionRepository.findByParentAndAppUser("t1", currentUser)).thenReturn(List.of());

        service.delete("t1");

        assertThat(parent.getAmount()).isEqualByComparingTo("250");
        verify(accountTransactionRepository).save(parent);
        verify(accountTransactionRepository).deleteByAppUserAndId(currentUser, "t1");
    }
}


